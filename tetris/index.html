<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Claude Tetris</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Press Start 2P', cursive;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #000;
            color: #fff;
            padding: 10px;
        }

        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #111;
            padding: 10px;
            border: 4px solid #fff;
            image-rendering: pixelated;
            margin-bottom: 10px;
        }

        #tetris-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        canvas {
            border: 4px solid #fff;
            image-rendering: pixelated;
        }

        #info-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #222;
            padding: 10px;
            border: 4px solid #fff;
        }

        #next-piece {
            border: 2px solid #fff;
            margin-top: 5px;
        }

        #score, #level {
            font-size: 12px;
            margin-bottom: 5px;
            color: #0f0;
        }

        #overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        #overlay-content {
            background-color: #111;
            color: #fff;
            padding: 20px;
            text-align: center;
            border: 4px solid #fff;
            max-width: 90%;
        }

        button {
            font-family: 'Press Start 2P', cursive;
            font-size: 14px;
            padding: 8px 16px;
            margin-top: 10px;
            cursor: pointer;
            background-color: #0f0;
            color: #000;
            border: none;
            image-rendering: pixelated;
        }

        button:hover {
            background-color: #0c0;
        }

        h1 {
            color: #0f0;
            margin-bottom: 10px;
            text-align: center;
            font-size: 18px;
        }

        #overlay-text {
            font-size: 18px;
            margin-bottom: 10px;
        }

        #final-score {
            font-size: 14px;
            margin-bottom: 15px;
            color: #0f0;
        }

        #back-button {
            background-color: #f00;
            color: #fff;
            text-decoration: none;
            display: inline-block;
            margin-top: 10px;
            font-size: 14px;
            padding: 8px 16px;
        }

        #back-button:hover {
            background-color: #c00;
        }

        @media (min-width: 768px) {
            #tetris-container {
                flex-direction: row;
            }

            body {
                padding: 20px;
            }

            #game-container {
                padding: 20px;
            }

            h1 {
                font-size: 24px;
            }

            #score, #level {
                font-size: 16px;
            }

            button {
                font-size: 16px;
                padding: 10px 20px;
            }
        }

        @media (max-width: 480px) {
            canvas#tetris {
                width: 180px;
                height: 300px;
            }

            canvas#next-piece {
                width: 60px;
                height: 60px;
            }

            #game-container {
                padding: 5px;
            }

            h1 {
                font-size: 16px;
                margin-bottom: 5px;
            }

            #score, #level {
                font-size: 10px;
            }

            button {
                font-size: 12px;
                padding: 6px 12px;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <h1>CLAUDE TETRIS</h1>
        <div id="tetris-container">
            <canvas id="tetris" width="300" height="500"></canvas>
            <div id="info-container">
                <div id="score">SCORE: 0</div>
                <div id="level">LEVEL: 1</div>
                <div>NEXT PIECE:</div>
                <canvas id="next-piece" width="100" height="100"></canvas>
            </div>
        </div>
        <a href="../index.html" id="back-button">Back to Experiments</a>
    </div>
    <div id="overlay">
        <div id="overlay-content">
            <h2 id="overlay-text">Welcome to Claude Tetris</h2>
            <p id="final-score"></p>
            <button id="start-button">Start Game</button>
            <button id="resume-button" style="display: none;">Return to Game</button>
            <button id="restart-button" style="display: none;">Restart Game</button>
        </div>
    </div>
<script>
    const canvas = document.getElementById('tetris');
    const ctx = canvas.getContext('2d');
    const nextPieceCanvas = document.getElementById('next-piece');
    const nextPieceCtx = nextPieceCanvas.getContext('2d');
    const scoreElement = document.getElementById('score');
    const levelElement = document.getElementById('level');
    const overlayElement = document.getElementById('overlay');
    const overlayTextElement = document.getElementById('overlay-text');
    const finalScoreElement = document.getElementById('final-score');
    const startButton = document.getElementById('start-button');
    const resumeButton = document.getElementById('resume-button');
    const restartButton = document.getElementById('restart-button');

    let ROWS, COLS, BLOCK_SIZE;
    let score = 0;
    let level = 1;
    let board = [];
    let currentPiece;
    let nextPiece;
    let isGameOver = false;
    let isPaused = false;
    let animationId;
    let dropInterval = 1000;
    let lastDropTime;

    const SHAPES = [
        [[1, 1, 1, 1]],
        [[1, 1], [1, 1]],
        [[1, 1, 1], [0, 1, 0]],
        [[1, 1, 1], [1, 0, 0]],
        [[1, 1, 1], [0, 0, 1]],
        [[1, 1, 0], [0, 1, 1]],
        [[0, 1, 1], [1, 1, 0]]
    ];

    const COLORS = [
        '#FF0D72', '#0DC2FF', '#0DFF72', '#F538FF',
        '#FF8E0D', '#FFE138', '#3877FF'
    ];

    function resizeGame() {
        if (window.innerWidth <= 480) {
            ROWS = 15;
            COLS = 9;
            BLOCK_SIZE = 20;
            canvas.width = 180;
            canvas.height = 300;
            nextPieceCanvas.width = 60;
            nextPieceCanvas.height = 60;
        } else {
            ROWS = 20;
            COLS = 12;
            BLOCK_SIZE = 20;
            canvas.width = 240;
            canvas.height = 400;
            nextPieceCanvas.width = 80;
            nextPieceCanvas.height = 80;
        }
        initGame();
    }

    function initGame() {
        board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
        score = 0;
        level = 1;
        dropInterval = 1000;
        isGameOver = false;
        isPaused = false;
        scoreElement.textContent = 'Score: 0';
        levelElement.textContent = 'Level: 1';
        currentPiece = createPiece();
        nextPiece = createPiece();
        drawNextPiece();
    }

    function drawBlock(x, y, color, context = ctx) {
        context.fillStyle = color;
        context.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        context.strokeStyle = '#000';
        context.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
    }

    function drawBoard() {
        board.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value > 0) {
                    drawBlock(x, y, COLORS[value - 1]);
                }
            });
        });
    }

    function drawPiece(piece, context, offsetX = 0, offsetY = 0) {
        piece.shape.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value > 0) {
                    drawBlock(piece.x + x + offsetX, piece.y + y + offsetY, COLORS[piece.color], context);
                }
            });
        });
    }

    function createPiece() {
        const shapeIndex = Math.floor(Math.random() * SHAPES.length);
        return {
            x: Math.floor(COLS / 2) - Math.ceil(SHAPES[shapeIndex][0].length / 2),
            y: 0,
            shape: SHAPES[shapeIndex],
            color: shapeIndex
        };
    }

    function drawNextPiece() {
        nextPieceCtx.clearRect(0, 0, nextPieceCanvas.width, nextPieceCanvas.height);
        const scale = nextPieceCanvas.width / (4 * BLOCK_SIZE);
        nextPieceCtx.scale(scale, scale);
        const offsetX = (4 - nextPiece.shape[0].length) / 2;
        const offsetY = (4 - nextPiece.shape.length) / 2;
        drawPiece({...nextPiece, x: 0, y: 0}, nextPieceCtx, offsetX, offsetY);
        nextPieceCtx.setTransform(1, 0, 0, 1, 0, 0);
    }

    function collide(piece) {
        for (let y = 0; y < piece.shape.length; y++) {
            for (let x = 0; x < piece.shape[y].length; x++) {
                if (piece.shape[y][x] && (board[y + piece.y] === undefined ||
                    board[y + piece.y][x + piece.x] === undefined ||
                    board[y + piece.y][x + piece.x] !== 0)) {
                    return true;
                }
            }
        }
        return false;
    }

    function merge(piece) {
        piece.shape.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value > 0) {
                    board[y + piece.y][x + piece.x] = piece.color + 1;
                }
            });
        });
    }

    function rotate(piece) {
        const rotated = piece.shape[0].map((_, i) =>
            piece.shape.map(row => row[i]).reverse()
        );
        if (!collide({ ...piece, shape: rotated })) {
            piece.shape = rotated;
        }
    }

    function clearLines() {
        let linesCleared = 0;
        outer: for (let y = board.length - 1; y >= 0; y--) {
            for (let x = 0; x < board[y].length; x++) {
                if (board[y][x] === 0) {
                    continue outer;
                }
            }
            board.splice(y, 1);
            board.unshift(Array(COLS).fill(0));
            linesCleared++;
            y++;
        }
        if (linesCleared > 0) {
            score += linesCleared * 100 * level;
            scoreElement.textContent = `Score: ${score}`;
            if (score >= level * 1000) {
                level++;
                levelElement.textContent = `Level: ${level}`;
                dropInterval = Math.max(100, 1000 - (level - 1) * 100);
            }
        }
    }

    function gameOver() {
        cancelAnimationFrame(animationId);
        isGameOver = true;
        overlayTextElement.textContent = 'Game Over';
        finalScoreElement.textContent = `Your final score: ${score}`;
        overlayElement.style.display = 'flex';
        startButton.style.display = 'block';
        startButton.textContent = 'Play Again';
        resumeButton.style.display = 'none';
        restartButton.style.display = 'none';
    }

    function checkGameOver() {
        if (board[0].some(cell => cell !== 0)) {
            gameOver();
            return true;
        }
        return false;
    }

    function update(time = 0) {
        if (isPaused) {
            animationId = requestAnimationFrame(update);
            return;
        }

        const deltaTime = time - lastDropTime;

        if (deltaTime > dropInterval) {
            movePiece(0, 1);
            lastDropTime = time;
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBoard();
        drawPiece(currentPiece, ctx);

        animationId = requestAnimationFrame(update);
    }

    function movePiece(dx, dy) {
        if (isPaused || isGameOver) return;
        currentPiece.x += dx;
        currentPiece.y += dy;
        if (collide(currentPiece)) {
            currentPiece.x -= dx;
            currentPiece.y -= dy;
            if (dy > 0) {
                merge(currentPiece);
                clearLines();
                if (checkGameOver()) return;
                currentPiece = nextPiece;
                nextPiece = createPiece();
                drawNextPiece();
            }
        }
        if (dy > 0) lastDropTime = performance.now();
    }

    function togglePause() {
        isPaused = !isPaused;
        if (isPaused) {
            cancelAnimationFrame(animationId);
            overlayTextElement.textContent = 'Paused';
            finalScoreElement.textContent = '';
            overlayElement.style.display = 'flex';
            startButton.style.display = 'none';
            resumeButton.style.display = 'block';
            restartButton.style.display = 'block';
        } else {
            overlayElement.style.display = 'none';
            lastDropTime = performance.now();
            animationId = requestAnimationFrame(update);
        }
    }

    document.addEventListener('keydown', event => {
        if (isGameOver) return;
        
        if (event.keyCode === 37) {
            movePiece(-1, 0);
        } else if (event.keyCode === 39) {
            movePiece(1, 0);
        } else if (event.keyCode === 40) {
            movePiece(0, 1);
        } else if (event.keyCode === 38) {
            if (!isPaused) rotate(currentPiece);
        } else if (event.keyCode === 27) { // Esc key
            togglePause();
        }
    });

    function startGame() {
        initGame();
        overlayElement.style.display = 'none';
        lastDropTime = performance.now();
        if (animationId) {
            cancelAnimationFrame(animationId);
        }
        animationId = requestAnimationFrame(update);
    }

    startButton.addEventListener('click', startGame);
    resumeButton.addEventListener('click', togglePause);
    restartButton.addEventListener('click', startGame);

    // Touch controls
    let touchStartX = 0;
    let touchStartY = 0;
    let touchEndX = 0;
    let touchEndY = 0;

    canvas.addEventListener('touchstart', function(event) {
        touchStartX = event.changedTouches[0].clientX;
        touchStartY = event.changedTouches[0].clientY;
    }, false);

    canvas.addEventListener('touchend', function(event) {
        touchEndX = event.changedTouches[0].clientX;
        touchEndY = event.changedTouches[0].clientY;
        handleSwipe();
    }, false);

    function handleSwipe() {
        const deltaX = touchEndX - touchStartX;
        const deltaY = touchEndY - touchStartY;
        const swipeThreshold = 30;

        if (Math.abs(deltaX) > Math.abs(deltaY)) {
            // Horizontal swipe
            if (Math.abs(deltaX) > swipeThreshold) {
                if (deltaX > 0) {
                    movePiece(1, 0); // Right
                } else {
                    movePiece(-1, 0); // Left
                }
            }
        } else {
            // Vertical swipe
            if (Math.abs(deltaY) > swipeThreshold) {
                if (deltaY > 0) {
                    movePiece(0, 1); // Down
                } else {
                    rotate(currentPiece); // Up (rotate)
                }
            }
        }
    }

    // Prevent default touch behavior to avoid scrolling
    canvas.addEventListener('touchmove', function(event) {
        event.preventDefault();
    }, { passive: false });

    // Call resizeGame on load and on window resize
    window.addEventListener('load', resizeGame);
    window.addEventListener('resize', resizeGame);

    // Show initial overlay
    overlayElement.style.display = 'flex';
</script>
</body>
</html>